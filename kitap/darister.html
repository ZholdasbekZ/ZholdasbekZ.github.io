<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Дәрістер</title>
	<link rel="stylesheet" href="style.css">
</head>
<body>
	<div class="wrapper">
		<header>
			<ul class="menu">
				<li class="menu_link"><a href="index.html">Басты бет</a></li>
				<li class="menu_link"><a href="darister.html">Дәрістер</a></li>
				<li class="menu_link"><a href="zh_all/zh_1.html">Зертханалық жұмыстар</a></li>
				<li class="menu_link"><a href="glossary.html">Глоссарий</a></li>
				<li class="menu_link"><a href="adebiet.html">Әдебиет</a></li>
			</ul>
		</header>
		<div class="box">
			<div class="left">
				<ol class="nav">
					<li class="nav-item">
						<a href="#1">Microsoft Visual С# програмалау ортасында жұмыс істеу негіздері. Алғашқы программа құру</a>
						<ol class="nav_sub">
							<li class="nav_sub-item"><a href="#1.1">C# программалау ортасы туралы жалпы мәліметтер</a></li>
							<li class="nav_sub-item"><a href="#1.2">С# тіліндегі ең қарапайым программа мысалы</a></li>
							<li class="nav_sub-item"><a href="#1.3">Программаны компиляциядан өткізу және орындау</a></li>
							<li class="nav_sub-item"><a href="#1.4">Программаны Visual Studio.NET ортасында орындау</a></li>
							<li class="nav_sub-item"><a href="#1.5">Программаны орындау</a></li>
						</ol>
					</li>
					<li class="nav-item">
						<a href="#2">C# тілінің элементтері</a>
						<ol class="nav_sub">
							<li class="nav_sub-item"><a href="#2.1">Тілдің құрамы</a></li>
							<li class="nav_sub-item"><a href="#2.2">Атаулар, айнымалылар және константалар</a></li>
							<li class="nav_sub-item"><a href="#2.3">C++ тіліндегі мәліметтер типтері</a></li>
							<li class="nav_sub-item"><a href="#2.4">C++ тілінің константалары</a></li>
							<li class="nav_sub-item"><a href="#2.5">C# тілінің негізгі операциялары</a></li>
						</ol>
					</li>
					<li class="nav-item"><a href="#3">C# тілінің операторлары</a></li>
					<li class="nav-item">
						<a href="#4">C# тілі негізінде Windows-қосымшаларын жасау</a>
						<ol class="nav_sub">
							<li class="nav_sub-item"><a href="#4.1">windows жүйесі ортасында программалау <br>ерекшеліктері</a></li>
							<li class="nav_sub-item"><a href="">оқиғалық басқару қағидасына негізделген<br> программалау</a></li>
							<li class="nav_sub-item"><a href="">visual Studio.NET ортасында жұмыс істеу<br> негіздері</a></li>
							<li class="nav_sub-item"><a href="">формалар</a></li>
							<li class="nav_sub-item"><a href="">шығарылымды көрсету – Обозреватель Решений</a></li>
							<li class="nav_sub-item"><a href="">қасиеттер терезесі – Окно Свойств</a></li>
						</ol>
					</li>
					<li class="nav-item"><a href="#5">Делегаттар</a></li>
					<li class="nav-item"><a href="#6">Енгізу-шығару мысалдары. Басқару операторлары элементтеріне мысалдар</a></li>
					<li class="nav-item"><a href="#7">Интерфейстер. Контейнерлік кластар</a></li>
					<li class="nav-item"><a href="#8">Кездейсоқ сандарды пайдалану. Символдар және сөз тіркестері</a></li>
					<li class="nav-item"><a href="#9">Класc тәсілдері мен операцияларының асыра жүктелуі</a></li>
					<li class="nav-item"><a href="#10">Кластарды мұралау</a></li>
					<li class="nav-item"><a href="#11">Кластардың негізгі элементтері- өрістерді, тәсілдерді, конструкторларды, қасиеттерді пайдалану жолдары</a></li>
				</ol>
			</div>
			<div class="right">
				<div class="container">
					<div class="theme1">
						<h2 class="theme" id="1">1. Microsoft Visual С# програмалау ортасында жұмыс істеу негіздері. Алғашқы программа құру</h2>
						<h3 id="1.1">1.1 C# программалау ортасы туралы жалпы мәліметтер</h3>
						<p>С# тілін («Си-шарп» деп айтылады, мұнда Бетховеннің «Ай сонатасындағы» музыкалық нотация — до-диез таңбасы (#) пайдаланылған; ағылшындар оны «си-шарп» деп оқиды) Microsoftкомпаниясының маманы Андерс Хейлзберг (Anders Hejlsberg) жаңа объектіге бағытталға программалау тілі ретінде С, C++, Java және BASIC тілдерінің негізінде жасап шығарған. Бұл пәнде осы тілдің негізгі элемент-тері қарастырылады.</p>
						<p>С # тілі Microsoft фирмасының .NET (дот-нет) архитектурасы үшін программалар жазуға арналған тілі. .NET – программалау технологиясындағы жаңа платформа, ол желіге қосыл-ған компьютерлерге арналып жасалған.</p>
						<p>.NET көмегімен шағын мобильді компьютер-лерде орындалатын программалар жазу ыңғай-лы деп есептеледі. Бұл технология Visual Studio.NET деп аталады да, бұл ортада Visual Basic, басқарылатын С++ және С # тілдерінде программалар жасау қарастырылған, бірақ ол осылармен ғана шектеліп қалмайды.</p>
						<p>С # тілінің мүмкіндігі Java тілімен қатарлас, осы екі тіл қазіргі алдыңғы қатарлы технологияларға жатады. С# тілін сүйемелдейтін .NET платформасының программа жасау ортасы бастапқы программаны бірден машиналық кодқа емес, MicroSoft Intermediate Language (MSIL не IL) атты аралық тілге аударады. Ол ОЖ-дан, ком-пьютер типінен тәуелсіз командалардан тұра-ды да, бірден орындалмай, тілдің жалпы орындалу ортасы Common Language Runtime – CLR деп аталатын жүйе арқылы атқары-лады. CLR ортасы кез келген ОЖ-да орында-ла береді. Программаны орындау кезінде, CLR JIT-компиляторын (just in time – дер кезінде) шақырады. Компилятор программаны бөліктерге бөле отырып, оның тек осы сәтте керек бөлігін ғана орындайды.</p>
						<img src="img/1.jpg" alt="">
						<p>Компилятор жұмысы нәтижесінде құрас-тыру (сборка) деп аталатын ехе немесе dll типті файл жасалады, онда IL тіліндегі код пен метамәліметтер болады.</p>
						<p><i>Метамәліметтер программада қолда-нылатын объектілер және құрастыру туралы ақпарат сақтайды.</i> Ол тіларалық әрекеттесу, қауіпсіздік, сенімділік сияқты мүмкіндіктерді қамтамасыз етеді.</p>
						<p>.NET платформасында көлемді кластар кітапханасы бар, оны осы ортадағы кез келген тілде пайдалана беруге болады.</p>
						<h3 id="1.2">1.2 С# тіліндегі ең қарапайым программа</h3>
							<p>/* Example1_1.cs файлы<br>
							"Hello world!“ программасы және ағымдағы мерзім мен уақытты экранға шығару */<br>
							class Example1_1<br>
							 { <br>
							 public static void Main() { // "Hello World!" сөзін экранға шығару<br>
							 System.Console.WriteLine("Hello World!");<br>
							 // ағымдағы мерзім мен уақытты шығару<br>
							 System.Console.WriteLine("The current date and time is " + System.DateTime.Now);<br>
							 }<br>
							}</p>						<p>Бастапқы Example1_1.cs файлы блокнотта немесе кез келген редакторда теріледі. Файл кеңейтілуі (типі) – cs. Осы тип барлық С# программаларына беріледі.</p>
													<p>Программаны TurboC# консолдық компиляторы (MS DOS) арқылы орындау үшін:</p>
													<p><b>csc Example1_1.cs</b> жолын тереміз. Компилятор бұл файлды машиналық кодқа түрлендіріп, Example1_1.ехе файлын жасайды. Оның ішкі мазмұнын, яғни программа нәтижесін көру үшін:</p>
													<p><b>Example1_1↵</b> жолын тереміз.
							Программа нәтижесі:
							Hello World!
							The current date and time is 28.08.2010 12:22:44 PM
							Программа нәтижесі аздап басқаша да болуы мүмкін, мысалы, мынадай:
							Hello World!
							The current date and time is 28.08.2010 12:22:44
							Енді программаның әрбір жолын жеке-жеке қарастырып шығайық.
							</p>
							<p>/* Example1_1.cs файлы "Hello world!“ программасы және ағымдағы мерзім мен уақытты экранға шығару */<br>
							Бұл С тілдері стиліндегі комментарий, компилятор мұны тек бос орын таңбасы деп есептейді, ол бізге оның жұмысын түсіну үшін ғана керек.<br>
							class Example1_1 {<br>
							Жүйелі жақша жаңа Example1_1 класының сипатталуы басталғанын көрсетеді. Жақша жабылғанда сипатталу бітеді. Класс ішінде айнымалылар, функциялар – тәсілдер болады.<br>
							public static void Main()<br>
							Бұл программаның басты функциясы Main (), ол бас әріппен жазылады. Программа осы функцияны орындаудан басталады.<br>
							public – бұл қатынасу деңгейінің модификаторы, ол осы тәсілге бұл кластан тыс қатынасу мүмкіндігін көрсетеді,<br>
							static – бұл сөз Main() тәсілінің нақты бір объектіге емес, класқа қатысты екенін білдіреді. Eгер static сөзі болмаса, бұл функцияны шақырмас бұрын осы класс объектісін жасап алу керек еді.<br>
							System.Console.WriteLine("Hello World!");<br>
							Бұл функция аты мына бөліктерден тұрады:<br>
							• System — атаулар кеңістігі;<br>
							• Console — сол атаулар кеңістігінде анықталған стандартты класс;<br>
							• WriteLine — осы класта анықталған тәсіл.<br>
							Программалардағы WriteLine және Write тәсіл-дері — Console класын экранға шығару ісін ат-қарады. Write тәсілі экранға (консольға) мәлімет шығарып, курсорды осы жолда қалдырады. Ал WriteLine тәсілі курсорды жаңа жолға көшіреді. Бұл ортада әртүрлі параметрлермен қолданылатын Write тәсілінің 18 сипаттамасы, ал Write-Line тәсілінің 19 сипаттамасы бар екен.<br>
							System.Console.WriteLine("The current date<br>
							and time is " + System.DateTime.Now);<br>
							Мұнда экранға күн-ай мерзімі мен уақытты беретін тәсіл мәлімет шығарады. Now — DateTime объектісінің қасиеті, ол жүйелік дата мен уақытты береді. Now — статикалық қаси-ет, сондықтан оны DateTime объектісін жаса-май-ақ қолдана беру ге болады.<br>
							Программа жұмысы нәтижесі:<br>
							<img src="img/2.jpg" alt="">
							<p>Тағы бір мысал<br>
							// Listing1_1.cs файлы<br>
							using System;<br>
							namespace ConsoleApplication1<br>
							{ /// <summary><br>
							 /// Summary description for Class1<br>
							/// </summary><br>
							class Class1<br>
							{ /// <summary><br>
							/// The main entry point for the application<br>
							/// </summary><br>
							[STAThread]<br>
							public static void Main(string[ ] args)<br>
							{ //<br>
							// TODO: Add code to start application<br>
							//<br>
							Console.WriteLine("Hello, World!");<br>
							}<br>
							}<br>
							}</p>
							<img src="img/3.jpg" alt="">
							</p>
							<p>Using System директивасы System атау-лар кеңістігінен тікелей стандартты класс аттарын (кеңістік атын көрсетпей) пайдалануға рұхсат береді.<br>
							namespace түйінді сөзі осы программа үшін ConsoleApplication1 атты өз атаулар ке-ңістігін жасайды. Бұл программа объектіле-ріне ат беруге болатынын көрсетеді.<br>
							2 не 3 қиғаш сызықтан басталатын жолдар комментарий болып саналады, 3 сызық прог-рамма комментарийлерінен құжат жасауға мүмкіндік береді.<br>
							C# тілі объектіге бағытталған тіл, сондықтан оның программасы бір-бірімен өзара бай-ланысқан кластардан тұрады. Бұл программада тек бір ғана класс бар, оған өзіміз Class1 деп ат бердік, класс сипаттамасы class түйінді сөзінен басталады да, аты жазылады.Сонан соң жүйелі жақша ішінде класс элементтері көрсетіледі. Олардағы функциялар мен мәлі-меттер тәсіл – метод деп аталады.<br>
							Жоғарыдағы класс ішінде тек бір элемент – Main методы, яғни тәсілі бар. Әр программада осындай бір басты тәсіл болады, программаны орындау содан басталады.<br>
							 <br></p>
							 <h3 id="1.3">1.3 Программаны компиляциядан өткізу және орындау</h3>
							<p>
							С# тіліндегі программа мәтін түрінде жазылады. Кез келген мәтіндік редактор арқылы программаны компьютерде тереміз де, артынан оны компиляциядан өткізіп, сонан соң орындап, нәтижесін аламыз.<br>
							Сонымен, компьютердің С# тіліндегі программаны орындауы үшін, оны маш-ина тіліне аударатын компилятор керек екені түсінікті шығар.<br>
							Компилятор программа мәтіні жазылған файлды оқып, оны талдайды, қателерін тексереді. Қателері түзетілген соң, программаны орындап, нәтиже беретін атқарылатын файл (исполняемый) жасайды.<br>
							Программаны бір рет компиляция-дан өткізген соң, оны әр түрлі бастапқы мәліметтер үшін атқарылатын файлды қайталап орындай отырып, нәтижелер аламыз.<br>
							Microsoft Windows NT, Windows 2000, Windows ХР, Windows 2007 операциялық жүйелерінде Visual Studio.NET ортасы қолданылады, ол программалаудыңбіріктірілген ортасы болып табылады, яғни құрамында C# тәрізді мәтіндік редакторды, компиляторды, т.б. қосымша програм-маларды біріктіріп тұрады.</p>
					</div> <!-- theme1 -->
					<div class="theme2">
						<h2 id="2">C# тілінің элементтері</h2>
						<h3 id="2.1">1.Тілдің құрамы</h3>
						<p>Кез келген табиғи тілдің мәтінінде символдар, сөздер, сөз тіркестері және сөйлемдер болады. Осындай элементтер программалау тілдерінде де болады, мұнда бірақ сөздер – лексемдер (қарапа-йым конструкциялар), сөз тіркестері – өрнектер деп, ал сөйлемдер – операторлар деп аталады.</p>
						<p>Лексемдер симолдардан тұрады, өрнектер – лексемдер мен символдардан, ал операторлар – символдардан, өрнектерден және лексемдерден тұрады.</p>
						<p>Тілдің алфавиті немесе оның символдары — бұл бөлінбейтін негізгі белгілер, солардантілдің барлық мәтіндері құрастырылады. С# тілінің алфавиті ретіне Unicode символдарықолданылады. Unicode кодтары барлық қолданылатын алфавиттерді бірден бейнелей алады. Оныңалғашқы 128 символы ANSI-кодтар кес-тесіне сәйкес келеді.</p>
						<p>Лексем (token-токен) немесе қарапайым конструк-ция — өзіндік мағынасы бар тілдің ең кішібірлігі. Олардың құрамы:</p>
						<ol>
							<li>Идентификаторлар;</li>
							<li>Түйінді сөздер;</li>
							<li>Операция таңбалары;</li>
							<li>Айыру таңбалары;</li>
							<li>Константалар (литералдар).</li>
						</ol><br><br>

						<h3 id="2.2">2. Атаулар, айнымалылар және константалар С# тілінің алфавиті Си ++ тілімен бірдейдеуге болады:</h3>
						<ul>
							<li>бас және кіші латын әріптері;</li>
							<li>0-ден 9-ға дейінгі араб цифрлары;</li>
							<li>арнайы белгілер: [] {} , . ( ) + - / * \ | % ; : ? <> = ! & # ^ " ';</li>
							<li>айыру символдары: бос орын (пробел), табуляция символы, жаңа жолға көшу таңбасы</li>
						</ul>
						<h3>Символдардан лексемдер құралады, олар:</h3>
						<ul>
							<li>идентификаторлар</li>
							<li>түйінді сөздер</li>
							<li>операция таңбалары</li>
							<li>костанталар, яғни тұрақтылар</li>
							<li>бөлгіштер (жақша, нүкте, үтір, айыру символдары)</li>
						</ul>
						<p>Идентификаторлар – программалық объектінің аты (атауы). Әріп немесе астын сызу таңбасыиденти-фикатордың бірінші символы болуы мүмкін, бірақ цифр бола алмайды.</p>
						<p>Идентификаторлармысалдары: <strong> X, bc, A12, Bagasy, BITES_PER_WORD , aty_goni</strong></p>
						<p><strong>Түйінді сөздер (keyword)</strong> –компилятор үшін арнайы мәні бар қордағы (резервтегі) идентификаторлар.</p>
						<p><strong>Операция таңбалары</strong> – операндтармен (мәндер-мен) іс-әрекет атқару үшін қолданылатын бірнемесе бірнеше символдар.</p>
						<p><strong>Тұрақтылар</strong> – программа орындалу барысында өзгермейтін шамалар.</p>
						<p><strong>Комментарийлер </strong>– компилятор үшін маңызы жоқ программаның бөлігі және программа мәтінін оқу ыңғайлы болуы үшін қолданылады. Ол /* және */ қоршалып тұрады немесе жолсоңында // символынан басталады.</p>
						<h3>С# тілінің түйінді сөздері тізімі</h3>
						<img src="img2/1.jpg" alt="">
						<h3 id="2.3">3.С# тіліндегі мәліметтер типтері</h3>
						<p>С# тілі қатаң түрде типтелген тіл, яғни әрбір ай-нымалы немесе объект данасы белгілі біртипке жатқызылуы тиіс, бұл орындалатын амалдардың дұрыстығын тексеру мүмкіндігін береді.</p>
						<p>Егер элементтер құрастырылуын негізге алсақ, онда типтер қарапайым және құрылымдыболып бөлінеді.</p>
						<p>Жасаушыға байланысты типтер құрамдас және программалаушы анықтаған болып бөлінеді.</p>
						<p>Статикалық типтегі мәліметке жады бірден бөлінеді де, динамкалық типтегі мәліметке жадыоны жариялау кезінде емес, оны программада пайдалану кезінде бөлінеді.</p>
						<h3>С# тіліндегі мәліметтер типтерін жіктеу түрлері</h3>
						<img src="img2/2.jpg" alt="">
						<p>С# тілінде құрамдас 15 тип бар, олардың сегізі бүтін сандық типке жатады. Олар — С# түйінді сөздерімен анықталады да, кез келген программада қолданыла береді.</p>
						<img src="img2/3.jpg" alt=""><br>
						<img src="img2/4.jpg" alt=""><br>
						<img src="img2/5.jpg" alt=""><br>
						<img src="img2/6.jpg" alt=""><br>
						<p>Программада кездесетін константалардың жазылуына қарай, яғни солардың сыртқыбейнесіне сәйкес белгілі бір тип тағайын-далады. Егер ол типті өзгерту керек болса, онда санныңсоңына жалғастырылып кер-екті типтің атына сәйкес бір әріп – L, l (long) немесе U, u (unsigned) жазылады. Мысалы, 32L константасының типі long және ол компьютердің жедел жадында 4 байт орын алады. Қажет болса, L және U әріптерін қатарластыра да қолдануға бола-ды, мысалы, 0x22UL немесе 05Lu.</p>
						<p>Мәліметтердің decimal типі үтірден кейінгі 28 таңбаға дейін сақтай алады, ол көбінесеақшалық мәндерді сақтау үшін қолданылады.</p>
						<p>Айнымалыға немесе константаға float типін бергенде, мән соңына "F" или "f " символынқоюға,<strong> мысалы:</strong></p>
						<p>double myDoublel = 1234.5678;<br>
						double myDouble2 = 1234.5678d;
						</p>
						<p>Символдық тип-Символдық тип char 16-биттік Unicode символ болып табылады.</p>
						<p><b>Unicode</b> – әлем тілдерінің барлық символдарын электрондық формада бейнелеуге арналғанстандарт.</p>
						<img src="img2/7.jpg" alt=""><br>
						<p>Төменде мәліметтердің 11 сандық типтерінің әрқайсысы үшін ең кіші (минимал) және еңүлкен (максимал) мәндерін көрсететін программа мысалы келтірілген.</p>
						<pre><b>// MinAndМax.cs программасы
						using System;
						class MinAndMax
						{ public static void Main()
						{ Console.WriteLine("sbyte: {0} to {1}",sbyte.MinValue, sbyte.MaxValue);
						Console.WriteLine("byte: {0} to {1}",byte.MinValue, byte.MaxValue);
						Console.WriteLine("short: {0} to {1}",short.MinValue, short.MaxValue);
						Console.WriteLine("ushort:{0} to {1}",ushort.MinValue, ushort.MaxValue);
						Console.WriteLine("int: {0} to {1}",int.MinValue, int.MaxValue);
						Console.WriteLine("uint: {0} to {1}",uint.MinValue, uint.MaxValue);
						Console.WriteLine("long: {0} to {1}",long.MinValue, long.MaxValue);
						Console.WriteLine("ulong: {0} to {1)",ulong.MinValue, ulong.MaxValue);
						Console.WriteLine("float: {0} to {1}",float.MinValue, float.MaxValue);
						Console.WriteLine("double:{0} to {1}",double.MinValue, double.MaxValue);
						Console.WriteLine("decimal:{0} to {1}",decimal.MinValue, decimal.MaxValue);
						}
						}
						Программа жұмысы нәтижесі:
						sbyte : -128 to 127
						byte: 0 to 255
						short: -32768 to 32767
						ushort: 0 to 65535
						int: -2147483648 to 2147483647
						uint: 0 to 4294967295
						long: -9223372036854775808 to 9223372036854775807
						ulong: 0 to 18446744073709551615
						float : -3.402823E+38 to 3.402823E+38
						double: -1.79769313486232E+308 to 1.797693134862Э2Е+308
						decimal: -79228162514264337593543950335 to 79228162514264337593543950335</b>
						</pre>
						<img src="img2/8.jpg" alt=""><br>
						<p># тілінде bool типі бар, ол true немесе false сияқты екі мәнді қабылдай алады. Салыстыруоперацияларының нәтижелері (==, !=, <, >, <= и >=) — bool типінде болады. Bool типі бүтін типкекелтіріледі (true – 1, ал false — 0), бірақ ол тікелей орындалуы тиіс.</p>
						<p>Char типі бір символды, aл string — бірнеше сим-волдардан тұратын сөз тіркестерін сақтауүшін қажет.</p>
						<p>Char типі бүтін типтерден өзгеше болып келеді және де оны sbyte немесе byte типтеріменшатастыр-мау керек. </p>
						<p>Char типіндегі айнымалылар 16 бит (бірақ ол short немесе ushort типтеріненөзгеше) орын алады.</p>
						<p>С# тілінде мәліметтер типтерінің элементтерді сақтау тәсіліне қарай тағы екі категориясы(санаты) бар: мәндертиптері (value types) және сілтемелік типтер. Мәндертиптері дегеніміз шамағакомпи-лятор бөліп берген компьютер жадындағы биттер тізбегі.</p>
						<p>Сілтемелік типтер мәліметтердің өздерін емес, олардың адрестерін сақтайды, мұндағы мәнкомпью-тердің динамикалық жадындағы басқа бір объектіге (үйіндіге – кучаға) сілтеу арқылыжасалады. Мәндер типтеріне логикалық тип, арифметикалық тип, құры-лымдар және саналатын(перечисления) типтер жа-тады. Сілтемелік типтерге жиымдар, сөз тіркестері (жолдар) жәнекластар жатады.</p>
						<h3 id="2.4">4. C# тілінің константалары</h3>
						<img src="img2/9.jpg" alt=""><br>
						<img src="img2/10.jpg" alt=""><br>
						<pre><b>/* Example2_7.cs константаларды қолдану */
						class Example2_7
						{ public static void Main()
						{
						const int Length = 3;
						// математикалық константа Пи
						const double Pi = 3.14159;
						// жарық жылдамдығы метр/секунд const double SpeedOfLight = 2.99792е8; Console.WriteLine("Length = " + Length);
						Console.WriteLine("Pi = " + Pi);
						Console.WriteLine("SpeedOfLight = " + SpeedOfLight);
						}
						}
						Программа нәтижесі
						Length = 3
						Pi = 3.14159
						SpeedOfLight = 299792000
						</b></pre>
						<img src="img2/11.jpg" alt=""><br>
						<h3 id="2.5">5. C# тілінің негізгі операциялары</h3>
						<p>Төменде C# негізгі операциялары олардың приоритеттері бойынша берілген. Операндтарының санына қарай олар унарлық, бинарлық және тернарлық болып бөлінеді.</p>
						<img src="img2/12.jpg" alt=""><br>
						<pre><b>// Инкремент (++) және декремент (--) операциялары
						using System;
						namespace Increment1
						{ class Class1
						{ static void Main()
						{
						 int x = 3, y = 3;
						Console.Write("Prefix opnek mani: ");
						Console.WriteLine( ++x);
						Console.Write(" х-ting natigelik mani: ");
						Console.WriteLine( x);
						Console.Write("Postfix opnek mani: ");
						Console.WriteLine( y++);
						Console.Write(" y-ting natigelik mani: ");
						Console.WriteLine( y);
						}
						}
						}
						Программа жұмысы нәтижесі:
						Prefix opnek mani: 4
						х-ting natigelik mani: 4
						Postfix opnek mani: 3
						y-ting natigelik mani: 4
						</b></pre>
						<img src="img2/13.jpg" alt=""><br>
						<p>Көбейту операциясы int, uint, long, ulong, float, double, decimalтәрізді арифметикалық типтегіоперандтарға қолданылады. Егер екі операнд та бүтін сан болса, бөлінді де бүтін сан болады.</p>
						<p>Бөлу операциясыда жоғарыдағы арифме-тикалық типтегі операндтарға қолданылады. Егер екіоперанд та бүтін сан болса, бөлінді де бүтін сан болады, әйтпесе бөлінді типі тип-терді түрлендіруережесіне сәйкес тағайын-далады.</p>
						<p>Қалдық табу (%) операциясы әртүрлі типтегі - бүтін, нақты, қаржылық шамаларғақолданылады. Егер екі опе-ранд та бүтін сан болса, нәтиже x-(x/y)*y формуласымен анықталады. Егер бір операнд нақты сан болса, нәтиже x-n*y (n – х-ті у-ке бөлгендегі бүтін сан) формуласыменанықталады.</p>
						<pre><b>Мысалы:
						using System; // Kaldyk_tabu.cs программасы
						namespace Kakdyk_tabu
						{ class Class1
						{ static void Main()
						{ int x = 11, y = 4; float z = 4;
						Console.WriteLine("x = {0} y = {1} z = {2}",x,y,z);
						// Нәтиже x = 11 y = 4 z = 4
						Console.WriteLine("z * y = " + z * y);
						// Нәтиже 16
						Console.WriteLine("z * 1e308 = " + z * 1e308);
						// Нәтиже шексіздік
						Console.WriteLine("x / y = " + x / y);
						// Нәтиже 2 Console.WriteLine("x / z = " + x / z);
						// Нәтиже 2.75 Console.WriteLine("x % y = " + x % y);
						// Нәтиже 3 Console.WriteLine("1e-324 / 1e-324 = " + 1e-324 / 1e-324);
						// Нәтиже NAN
						}
						}
						}
						</b>
						</pre>
						<img src="img2/14.jpg" alt=""><br>
					</div> <!-- theme2 -->
					<div class="theme3">
						<h2 id="3">C# тілінің операторлары</h2>
						<ol>
							<b><li>Жалпы мәліметтер</li>
							<li>Тармақталу операторы</li>
							<li>Ауыстырғыш оператор</li>
							<li>Циклдік операторлар</li>
							<li>C# тіліндегі жиымдар</li>
							<li>Бір өлшемді жиымдар</li>
							<li>Төртбұрышты жиымдар</li>
							<li>Сатылы жиымдар</li></b>
						</ol>
						<h3 id="3.1">1.Жалпы мәліметтер</h3>
						<p>Кез келген программаны алгоритм блокта-рының өзара байланысуына қарай үш түрлі басқаруқұрылымынан жасауға болады. Оларды құрылымдық программалаудың базалық құрас-тырғыштары(конструкциялары) деп атайды.</p>
						<p>Бірнеше операторлардың тізбектей орында-луынан тұратын құрастырғыш реттік (сызық-тық) деп аталады. Қандай да бір шарттың орын-далуына тәуелді құрастырғышты тармақталу депатаймыз. Цикл операторлар тізбегінің бірнеше рет қайталап орындалуын білдіреді.</p>
						<p>Оператор – тілдің қарапайым сөйлемі, ол белгілі бір әрекет немесе амал орындап, ;таңбасымен аяқталады.</p>
						<p>Сызықтық (реттік) құрылым бірінен кейін бірі орындалып тізбектеле орналасқан бір-нешеоператорлардан тұрады.</p>
						<p>Тармақты – шартқа байланысты екі оператордың бірінің орындалуы</p>
						<p>Цикл – операторлар бөлігінің бірнеше рет қайталана орындалуы.</p>
						<p>Кез келген нүктелі үтірмен аяқталатын өрнек оператор болып саналады. Ол көбінесе берілгенөрнек бойынша есептеу ісін атқарады. Бос опера-тор да өрнектің бір түрі болып табылады. </p>
						<h4>Мысалдар:</h4>
						<p>i++; // инкремент операциясы</p>
						<p>a *= b+c; // көбейтіп меншіктеу амалы</p>
						<p>fun(i, k); // функцияны шақыру орындалады</p>
						<p>while(true); // бос оператордан цикл (шексіз)</p>
						<p>Блок немесе құрама оператор – бұл жүйелі жақшалармен шектелген сипаттамалар меноператорлар тізбегі {…}. Блок компилятор үшін бір оператор сияқты орындалады, ол синтаксисбойынша бір оператор болғанмен, алгоритм бойынша бірнеше операторлардан тұрады.</p>
						<h4>Басқару операторлары</h4>
						<p>Бұлар программадағы операторлардың орын-далу реттілігін анықтайды да, алгоритмдерді жү-зеге асырудың негізгі құралы болып табылады.</p>
						<h4>Басқару операторларының түрлері (категория-лары – санаттары):</h4>
						<ol>
							<li>Таңдау операторлары, олар мынадай түйінді сөздер арқылы енгізіледі: if, if ... else ..., switch.</li>
							<li>Циклдік (қадамдық – итеративтік) операторлар, while, do ... while, for, foreach түйінді сөздеріарқылы енгізіледі.</li>
							<li>Көшу (ауысу) операторлары, goto, break, continue түйінді сөздері арқылы енгізіледі.</li>
						</ol>
						<h3 id="3.2">Таңдау (тармақталу) операторы</h3>
						<p>Тармақталу операторлары: if, else және ауыстырғыш оператор: switch
						if шартты операторы есептеу жолының екі бағытта тармақталуын жүзеге асырады.
						</p>
						<h4>Оператор форматы:</h4>
						<p>if(өрнек) 1-оператор;[else2-оператор;] <br>
						Шартты оператордың құрылымдық схемасы.
						</p>
						<h4>Switch операторы</h4>
						<p>switch (ауыстырғыш) операторы есептеу процесін бірне-ше тармаққа бөліп жібереді. Оныңалгоритмдік схемасы келесі слайдта көрсетілген.<br> Оператор форматы:</p>
						<pre><b>switch ( өрнек )
						{
						case 1_тұрақты_өрнек: [1_операторлар_тізімі]
						case 2_тұрақты_өрнек: [2_операторлар_тізімі]
						...
						case n_тұрақты_өрнек: [n_операторлар_тізімі]
						[default: операторлар ]
						}
						</b></pre>
						<h4>C# тіліндегі жиымдар (массивтер)</h4>
						<p>C# тіліндегі жиымдар C/С++ тілдерінен өзгеше-леу болып келеді. Бірден мысалдар келтірейік.</p>
						<pre><b>int[ ] k; //k жиымын анықтау
						k=new int [3]; //3 бүтін саннан тұратын жиым
						k[0]=-5; k[1]=4; k[2]=55; //Жиым элементтері
						//Жиымның 3-элементін экранға шығару
						Console.WriteLine(k[2].ToString());
						Бұлар түсінікті шығар. Жиым былай анықталады:
						int[ ] k;
						Мынадай вариантлар дұрыс емес:
						int k[ ]; // Қате!
						int k[3]; // Қате!
						int [3] k; // Қате!
						</b></pre>
						<p>Жиымды сипаттау үшін мәлімет типінен соң, бос тік жақшалар қойылады да, оның атыжазылады:</p>
						<p><b>float[ ] ar;</b></p>
						<p>ar айнымалысының типі — жылжымалы нүктелі сандар жиымы (нақты сан), ал негізінде ar— бұл вариантуыш. С# тілінде жиым сілтемелік тип (refe-rence type) болып табылады. Сөз тіркесі де осы типке жатады.
						ar айнымалысының алғашқы анықталған мәні — null. Бұл жиымға компьютер жадынан орынбөлу үшін, new операторы арқылы жиымдағы элемент-тер санын көрсету керек:
						</p>
						<p><b>ar = new float[3];</b></p>
						<p>Жоғарыдағы екі операторды біріктіріп жазуға да болады:</p>
						<p><b>float[ ] ar = new float[3];</b></p>
						<p>Бұған қоса, жиымды сипаттау кезінде оны бірден инициалдауға болады:</p>
						<p><b>float[ ] ar = new float[3] { 3.14, 2.17, 100 };</b></p>
						<p>Инициалдау мәндерінің саны жиымда көрсетілген элементтер санымен сәйкес болуы тиіс.</p>
						<p>Инициалдау кезінде жиым элементтері санын бермеуге де болады:</p>
						<p><b>float[ ] аr = new float[] { 3.14, 2.17, 100 };<br>
						new сөзін жазбауға да рұхсат етілген:<br>
						float[ ] аr = { 3.14, 2.17, 100 };
						</b></p>
						<p>Кейіннен программада arайнымалысына басқа өлшемдегі float типін меншіктеуге де болады:</p>
						<p><b>ar = newfloat[5];</b></p>
						<p>Мұнда float типті 5 мәнді сақтауға арналған жады бөлінеді, алғашқыда олардың бәрінің де мәні 0-ге тең деп саналады.</p>
						<p>Алдыңғы бөлінген float типті 3 мәнді сақтауға арналған жады қоқыс ретінде (garbagecollection) өздігінен босатылады, өйткені С# тілінде delete операторы жоқ.</p>
						<p>С# тілінде бір өлшемді жиымдар және одан өзге жиымдардың жиымы болып табылатын екі(одан да көп) өлшемді төртбұрышты және сатылы (тураланбаған - jagged) жиымдар құру мүмкіндікбар.</p>
						<p>6 бүтін саннан тұратын ажиымының теріс элемент-терінің қосындысы мен санын және еңүлкен элемен-тін анықтайтын программа құрамыз.</p>
						<pre><b>using System;
						namespace Listing6_1
						{ class Class1
						{ static void Main()
						{ const int n = 6;
						int[ ] a = new int[n] { 3, 12, 5, -9, 8, -4 };
						Console.WriteLine("Берілген жиым:" );
						for ( int i = 0; i < n; ++i ) Console.Write( "\t" + a[i] );
						Console.WriteLine( );
						long sum = 0; // теріс элементтері қосындысы
						int num = 0; // теріс элементтері саны
						for ( int i =0; i < n; ++i )
						if ( a[i] < 0 )
						{ sum += a[i]; ++num; }
						Console.WriteLine(" Теріс сандар қосындысы = " + sum );
						Console.WriteLine(" Теріс сандар саны = " + num );
						int max = a[0]; // максимал элемент
						for ( int i = 1; i < n; ++i ) if ( a[i] > max ) max = a[i];
						Console.WriteLine( "Максимал элементі = " + max );
						}
						}
						}
						</b></pre>
						<img src="img3/1.jpg" alt="">
					</div>
					<!-- /.theme3 -->
					<div class="theme4">
						<h2 id="4">C# тілі негізінде Windows-қосымшаларын жасау</h2>
						<h3 id="4.1">Windows жүйесі ортасында программалау ерекшеліктері:</h3>
						<p>
						• Алдыңғы дәрістерде консолдық программалар жасау ар-қылы C# тілінің мүмкіндіктеріментаныстық. Енді Windows ортасында .NET кітапханалары жұмысын қарастырып, операциялық жүйемүмкіндіктерін толығырақ пайдалана бастаймыз.<br>
						• Windows жүйесі ортасында программалау ерекшеліктері:<br>
						• Көп тапсырмалы режим – жүйеде бір мезетте бірнеше программа жұмыс істей алады, әрпрограммаға жеке жа-ды аймағы бөлініп, процессор уақыты да бөлініп беріліп, сыртқықұрылғыларды да олар ортақ пайдалана алады;<br>
						• Программалар аппаратурадан тәуелсіз істейді – олар тікелей құрылғыларға емес, ОС-мен байланыс жасайды, сондықтан құрылғылардың параметрлерін программа есепке алмайды, олардрайверлер арқылы басқарылады.<br>
						• Қолданушымен стандартты түрде графикалық интер-фейс орнатылып, әр программа бір терезеарқылы тұтынушымен байланысады, терезелер стандартты элементтерден тұрады;<br>
						• Әртүрлі программалар арасында мәлімет алмасу ісі жүргізіледі, олар буфер арқылы немесе OLE мүмкінді-гімен жүргізіле береді;<br>
						• Ескі программаларды да орындау мүмкіндігі – Windows жүйесінің 32-разрядты ортасында 16-разрядты орта программалары, MS DOS жүйесінің программалары да орындала береді;<br>
						• Windows-қосымшаларын жасайтын оқиғалық басқару қағидасына негізделген программалауорындалады.<br>
						Оқиғаны Windows жүйесі қабылдап, хабарламаға (тышқан шертілді, перне басылды) түрлендіреді, Хабарлама қолданушыдан да, ОС-тан да, басқа программадан да келуі мүмкін. Стандартты хабар-ламалардың бірнеше түрлері бар, олар иерархияға сәйкес жұмыс істейді.<br>
						Хабарламалар жалпы кезекке келіп түседі де, сонан кейін қосымшалар арасында кезеккетұрады. Әрбір қосымша программаның хабарламаларды өңдеу циклі болады, солар хабарламалардыкезекпен ала отырып, ОС арқылы соны өңдейтін ішкі программаларды шақырады.</p>
					</div>
					<!-- /.theme4 -->
					<div class="theme5">
						<h2 id="5">Делегаттар</h2>
						<p>Делегаттың анықтамасы<br>
						•Делегат— бұл тәсілдерге сілтемелерді сақтауға арналған класс түрі. Делегатты кез кезген класс тәрізді параметр ретінде беруге, осыдан кейін ондағы инкапсуляцияланған тәсілді шақыруғаболады.<br>
						• Делегаттар оқиғаларды қолдау үшін, сонымен қатар, тілдің тәуелсіз конструкциясы ретіндеқолданылады.<br>
						• Делегаттың сипаттамасы оның көмегімен шақырылуы мүмкін тәсілдер сигнатурасын анықтайды:<br>
						• [ атрибуттар ] [ спецификаторлар ] delegate тип аты(<br>
						• [ параметрлер ] )<br>
						• Делегатты сипаттау мысалы:<br>
						• public delegate void D ( int i );<br>
						• Делегаттың базалық класы System.Delegate болып табылады<br>
						 <br>
						Делегаттарды қолдану<br>
						 <br>
						• Делегаттар, негізінен, келесідей жағдайлар үшін қолданылады:<br>
						• шақырылған тәсілді компиляция кезінде емес, программаның орындалуы кезінде динамикалықтүрде анықтауға мүмкіндік алу;<br>
						• объектілер арасында «шығу көзі — бақылаушы» типі бойынша байланысты қамтамасыз ету;<br>
						• оларға басқа тәсілдерді беруге болатындай әмбебапты (универсалды) тәсілдерді құру (керішақырулар механизмін қолдау).<br>
						 <br>
						Операциялар<br>
						 <br>
						• Делегаттарды теңдікпен немесе теңсіздікпен салыстыруға болады. Егер екі делегаттың екеуінде де тәсілдерге сілтеме болмаса немесе екеуінде де бірдей тәсілдерге бірдей реттілікпен сілтемелержасалған болса, олар тең болады.<br>
						• Бірдей типті делегаттармен қарапайым және күрделі меншіктеу операцияларын орындауғаболады.<br>
						• string тіркестері сияқты, делегат та өзгермейтін мәлімет типі болып табылады, сондықтан кезкелген өзгерістер жағдайында жаңа экземпляр құрылады, ал ескісін кейіннен қоқыс жинаушы(сборщик мусора) өшіріп тастайды, яғни жояды.<br>
						• Делегатты қолдану синтаксисі тәсілді шақыру синтаксисімен бірдей болып келеді. Егер делегаттабірнеше тәсілге сілтемелер сақталатын болса, олар тізбектеле, делегатқа қосылған реттілігіменшақырылады.<br>
						 <br>
						Оқиғалар<br>
						 <br>
						• Оқиғаның анықтамасы<br>
						• Оқиғалар механизмі<br>
						• Делегаттар мен оқиғалар туралы қосымша<br>
						 <br>
						Оқиғаның анықтамасы<br>
						 <br>
						• Оқиға — кластың басқа объектілеріне (бақылаушыларға) өздерінің күйінің өзгеруі туралыхабарламалар жіберуіне мүмкіндік беретін класс элементі.<br>
						• Бақылаушы болу үшін объектінің оқиғаларды өңдеушісі болуы керек және ол оқиғалар өңдеушісіншығу көзі объектісінде (в объекте-источнике) тіркеу керек.<br>
						 <br>
						Мысал<br>
						class Subj { // -------------- Оқиғаның шығу көзі (класс-источник)<br>
						public event EventHandlerOops; // Станд . типті оқиғаны сипаттау<br>
						public void CryOops() { // Оқиғаны тудыратын тәсіл<br>
						Console.WriteLine( "OOPS!" ); if ( Oops != null ) Oops( this, null ); }<br>
						} class Obs { // --------------- Бақылаушыкласс --------------------------<br>
						public void OnOops( object sender, EventArgs e ) { // Оқиғаны өңдеуші<br>
						Console.WriteLine("Оййй!" );<br>
						}<br>
						}<br>
						class Class1 {<br>
						static void Main() {<br>
						Subj s = new Subj();<br>
						Obs o1 = new Obs();<br>
						Obs o2 = new Obs();<br>
						s.Oops += o1.OnOops; // өңдеушіні тіркеу<br>
						s.Oops += o2.OnOops; // өңдеушіні тіркеу<br>
						s.CryOops();<br>
						}<br>
						}<br>
						 <br>
						Оқиғалар механизмі<br>
						 <br>
						• Оқиғалар делегаттар негізінде құрастырылған: делегаттардың көмегімен оқиғаларды өңдеушітәсілдер шақырылады. Сондықтан класта оқиғаны құру келесі бөлімдерден тұрады:<br>
						o оқиғалар өңдеушілерінің сигнатурасын анықтайтын делегатты сипаттау;<br>
						o оқиғаны сипаттау;<br>
						o Оқиғаны тудыратын тәсілді (тәсілдерді) сипаттау.<br>
						• Оқиғаның синтаксисі:<br>
						• [ атрибуттар ] [ спецификаторлар ] event тип аты</p>
					</div>
					<div class="theme6">
						<h2 id="6">Енгізу-шығару мысалдары. Басқару операторлары элементтеріне мысалдар</h2>
						<ol>
							<li>Консольдік енгізу-шығару (Console класы ) мүмкіндіктері;</li>
							<li>Басқару операторлары элементтері (тармақ, цикл, басқаруды беру).</li>
						</ol>
						<h3 id="6.1">Консольге мәлімет шығару</h3>
						<pre><b>using System;
						namespace A
						{ class Class1
						{ static void Main()
						{
						int i = 3;
						double y = 4.12;
						decimal d = 600m;
						string s = "Берік";
						Console.Write( i );
						Console.Write( " y = {0:F2} \nd = {1:D3}", y, d );
						Console.WriteLine( " s = " + s );
						}
						}
						}
						</b></pre>
						<h3>Консольден мәлімет енгізу</h3>
						<pre><b>using System;
						namespace A
						{ class Class1
						{ static void Main()
						{
						string s = Console.ReadLine(); // вводстроки
						char c = (char)Console.Read(); // вводсимвола
						Console.ReadLine();
						stringbuf; // буфердлявводачисел
						buf = Console.ReadLine();
						int i = Convert.ToInt32( buf ); // преобразованиевцелое
						buf = Console.ReadLine();
						double x = Convert.ToDouble( buf ); // преобразованиеввещ.
						buf = Console.ReadLine();
						double y = double.Parse( buf ); // преобразованиеввещ.
						}
						}
						}
						</b></pre>
						<h3 id="6.2">Басқару операторларының элементтері<br>Блок (құрама оператор)</h3>
						<p>Блок — жүйелі жақшаларға алынған операторлар тізбегі:</p>
						<p><b>begin end { }</b></p>
						<p>Блок компилятор үшін бір оператор болып саналады, синтаксис бойынша бір оператор керекболғанмен, алгоритм бойынша — бірнеше оператор орындалады.
						Блокта бір-ақ оператор болуы мүмкін, кейде ол тіпті бос болады.
						</p>
						<p><b>«Өрнек» операторы</b></p>
						<p>Нүктелі үтірмен аяқталған кез келген өрнек оператор болып есептеледі, ол белгілі бір амалдарорындауды керек етеді.</p>
						<p>i++; // выполняется операция инкремента<br>
						a *= b + c; // выполняется умножение с присваиванием<br>
						fun( i, k ); // выполняется вызов функции<br>
						</p>
						<h3>Бос оператор</h3>
						<p>o Бос оператор ; синтаксис бойынша оператор керек болғанмен, мағынасы бойынша — олқажет етілмегенде қолданылады:</p>
						<p>o while ( true );</p>
						<p>Бос оператордан тұратын бұл цикл шексіз орындалуды көрсетеді</p>
						<p>o ;;;</p>
						<p>Үш бос оператор</p>
						<h3>Тармақталу операторы:</h3>
						<pre><b>o тармақталу (if)
						o ауыстыру (switch)
						if шартты операторы
						if ( a < 0 ) b = 1;
						if ( a < b && (a > d || a == 0)) ++b;
						else { b *= a; a = 0;
						}
						if ( a < b ) if ( a < c ) m = a;
						else m = c;
						else if ( b < c ) m = b;
						else m = c;
						</b></pre>
					</div>
					<!-- /.theme6 -->
					<div class="theme7">
						<h2 id="7">Интерфейстер. Контейнерлік кластар</h2>
						<p>
						• интерфейстерді сипаттау және қолдану;<br>
						• объектілерді клондау, салыстыру, реттеу үшін стандартты .NET; интерфейстерін қолдану;<br>
						• контейнер (коллекция) түсінігі;<br>
						• стандартты .NET топтамаларын (коллекция) қолдану.<br>
						 -<br>
						Интерфейстер. Интерфейс туралы жалпы мағлұматтар<br>
						 <br>
						• интерфейс кластардың арнайы бір түрі, ол абстрактілі кластың «шеткі бір түрі (жағдайы)» болыптабылады. Интерфейсте туынды класта жүзеге асырылуы тиіс абстрактілі тәсілдер, қасиеттер жәнеиндексаторлардың жиыны беріледі.<br>
						• интерфейс оны іске асыратын кластар қолдайтын әрекет-терді анықтайды.<br>
						• интерфейсті қолданудың негізгі идеясы – осындай класс объектілерін бірдей жолдармен қолдануғамүмкіндік беру.<br>
						• әрбір класс интерфейс элементтерін өз қалауынша анық-тай алады. Осылайша полиморфизмге қолжеткізіледі: әртүрлі класс объектілері бір тәсілдің шақыруына әртүрлі жауап әрекеттер орындайалады.<br>
						• интерфейс синтаксисі класс синтаксисіне ұқсас:<br>
						• [ атрибуттар ] [ спецификаторлар ] interface аты [ : ата_тегі ]<br>
						• интерфейс_тұлғасы [ ; ]<br>
						• Бір интерфейсте бірнеше интерфейс қасиеттері мұра-лану мүмкіндігі бар, мұндайда олардың ата-тектері үтір арқылы бөліне отырып жазылады.<br>
						• Интерфейс тұлғасын абстрактілі тәсілдер, қасиеттер мен индексаторлар шаблондары, оқиғаларқұрайды.<br>
						• Интерфейс құрамында тұрақтылар, өрістер, операция-лар, конструкторлар, деструкторлар, типтержәне кез келген статикалық элементтер болмауы тиіс.<br>
						interface IAction<br>
						{<br>
						void Draw();<br>
						int Attack(int a);<br>
						void Die();<br>
						int Power { get;<br>
						}<br>
						 <br>
						Интерфейстердің қолданылу аймағы<br>
						•Егер қандай да бір әрекеттер жиынын қолдану тек осы әрекеттерді әртүрлі тәсілдерменорындайтын нақты бір кластар иерархиясы үшін маңызды болса, бұл жиынды иерархияныңабстрактілі базалық класының виртуалды тәсілдері түрінде берген жөн.<br>
						•Иерархия шегінде (ішінде) бірдей жұмыс істейтін мүмкіндіктердің барлығын толығымен базалықкласта анықтаған жөн.<br>
						•Интерфейстер көп жағдайда әртүрлі иерархия объектілерінің ортақ қасиеттерін көрсету үшінқолданылады.<br>
						 <br>
						Интерфейстерді жүзеге асырудың ерекшеліктері<br>
						 Интерфейсті жүзеге асыратын класс оның барлық элементтерін, оның ішінде, мұраланғандарында анықтауы керек. Егер осындай жағдайда интерфейстің аты нақты түрде көрсетілетін болса, олосыған сәйкес элемент сипатталған интерфейске сілтеме жасауы тиіс.<br>
						 Өзіндік немесе мұраланған элементтерге нақты сілтеме жасайтын интерфейс класс ата-тектерітізімінде көрсетілуі тиіс.<br>
						 Класс өзінің ата тегінің барлық тәсілдерін, оның ішінде, интерфейстерді жүзеге асырғандарын дамұралайды. Ол осы тәсілдерді new спецификаторының көмегімен қайта анықтай алады, алайдаолармен тек класс объектісі арқылы ғана қатынас құруға болады.<br>
						Параметрлері бар топтамалар (коллекциялар)(класс-прототиптер, generics)<br>
						параметрлері ретінде мәліметтер типтері болатын кластар<br>
						 <br>
						<img src="img/4.jpg" alt=""><br>
						class Program {<br>
						static void Main() {<br>
						List<int> lint = new List<int>();<br>
						lint.Add( 5 ); lint.Add( 1 );<br>
						lint.Add( 3 ); lint.Sort();<br>
						int a = lint[2];<br>
						Console.WriteLine( a );<br>
						foreach ( int x in lint ) Console.Write( x + " ");<br>
						}<br>
						}<br>
						}</p>
					</div>
					<!-- /.theme7 -->
					<div class="theme8">
						<h2 id="8">Кездейсоқ сандарды пайдалану. Символдар және сөз тіркестері<br></h2>
						<p>· Кездейсоқ сандар тізбегін алу;<br>
						 <br>
						Жиымдарды пайдаланатын программаларда олардың мәні ретінде кездейсоқ сандардықолданған ыңғайлы болып табылады.<br>
						С# кітапханасында кездейсоқ сандар беретін Random класы бар, ол System атауларкеңістігінде анықталған.<br>
						Кездейсоқ сандар тізбегін алу үшін алдымен төмендегідей конструктор көмегімен класс экземплярын (данасын) жасау керек:<br>
						Random a = new Random(); // 1<br>
						Random b = new Random( 1 ); // 2<br>
						мұндағы 1-жолдағы параметрсіз конструктор кездейсоқ сандарды уақыт көрсеткіші негізіндеқрастырады. Сондықтан ол қайталаған сайын жаңа сандар тізбегін беріп отырады. Ал, 2-жолдағы int типіндегі параметрі бар конструктор қайталаған сайын тұрақты сандар тізбегін береді.<br>
						Кездейсоқ сандар тізбегін алу үшін алдымен төмендегідей конструктор көмегімен класс экземплярын (данасын) жасау керек:<br>
						Random a = new Random(); // 1<br>
						Random b = new Random( 1 ); // 2<br>
						мұндағы 1-жолдағы параметрсіз конструктор кездейсоқ сандарды уақыт көрсеткіші негізіндеқрастырады. Сондықтан ол қайталаған сайын жаңа сандар тізбегін беріп отырады. Ал, 2-жолдағы int типіндегі параметрі бар конструктор қайталаған сайын тұрақты сандар тізбегін береді.<br>
						 <br>
						<img src="img/5.jpg" alt=""><br>
						Кездейсоқ сандар тізбегін алу тәсілдерін пайдалану мысалы<br>
						using System;<br>
						namespace Listing6_10<br>
						{ class Class1<br>
						{static void Main()<br>
						{Random a = new Random();<br>
						Random b = new Random(1);<br>
						const int n = 10;<br>
						Console.WriteLine("\n Диапазон [0, 1]:");<br>
						for (int i = 0; i < n; ++i) Console.Write("{0 ,6:0.##}“,a.NextDouble());<br>
						Console.WriteLine("\n Диапазон [0, 1000]:");<br>
						for (int i = 0; i < n; ++i) Console.Write(" " + b.Next(1000));<br>
						Console.WriteLine("\n Диапазон [-10, 10]:");<br>
						for (int i = 0; i < n; ++i) Console.Write(" " + a.Next(-10, 10));<br>
						Console.WriteLine("\n Массив [0, 255]:");<br>
						byte[] mas = new byte[n];<br>
						a.NextBytes(mas); for (int i = 0;<br>
						i < n; ++i) Console.Write(" " + mas[i]);<br>
						}<br>
						}<br>
						}<br>
						 <br>
						<img src="img/6.jpg" alt="">
						 <br>
						Программа жұмысының нәтижесі:<br>
						Диапазон [0, 1]:<br>
						0,02 0,4 0,24 0,55 0,92 0,84 0,9 0,78 0,78 0,74<br>
						Диапазон [0, 1000]:<br>
						248 110 467 771 657 432 354 943 101 642<br>
						Диапазон [-10, 10]:<br>
						-8 9 -6 -10 7 49 -5 -2 -1<br>
						Массив [0, 255]:<br>
						181 105 60 50 70 77 9 28 133 150<br>
						 <br>
						1. Символдар мен сөз тіркестері<br>
						Мәтіндік мәліметтерді өңдеу программа-лаудағы ең бір жиі кездесетін жұмыс түрі болыпсаналады. Оның мынадай мүмкіндік-тері бар: символдарды, символдар жиымын, сөз тіркестерін, өзгермелі және өзгермейтін тіркестерді өңдеу, т.с.с.<br>
						1.1. Символдарды пайдалану<br>
						Символдық тип char Unicode кодтау жүйе-сінде символдарды сақтау үшін керек. Сим-волдықтип С# тілінің құрамдас типі болып саналады да, .NET кітапханасының System атауларкеңістігіндегі Char стандартты класы-на сәйкес келеді. Бұл класс символдарды анықтап, олардыңкатегориясын, төменгі немесе жоғарғы регистрге ауыстыруға қатысты статикалық тәсілдерді дебереді.<br>
						Енді мысалдар келтірейік<br>
						System.Char класы тәсілдерін пайдалану<br>
						using System;<br>
						namespace Listing6_6<br>
						{ class Class1<br>
						{ static void Main()<br>
						{ try<br>
						{<br>
						char b = 'В',c = '\x63',d = '\u0032'; // 1<br>
						Console.WriteLine("{0} {1} {2}", b, c, d);<br>
						Console.WriteLine("{0} {1} {2}", char.ToLower(b), char.ToUpper(c), char.GetNumericValue(d));<br>
						char a; do // 2 {<br>
						Console.Write("Введите символ: ");<br>
						a = char.Parse(Console.ReadLine());<br>
						Console.WriteLine("Введен символ {0}, его код - {1}", a, (int)a);<br>
						if (char.IsLetter(a))<br>
						Console.WriteLine("Буква");<br>
						if (char.IsUpper(a)) Console.WriteLine("Верхний peг.");<br>
						if (char.IsLower(a)) Console.WriteLine("Hижний peг.");<br>
						if (char.IsControl(a)) Console.WriteLine("Управляющий");<br>
						if (char.IsNumber(a)) Console.WriteLine("Число");<br>
						if (char.IsPunctuation(a)) Console.WriteLine("Paздeлитeль");<br>
						} while (a != 'q');<br>
						}catch {Console.WriteLine("Возникло исключение");<br>
						return;<br>
						}<br>
						}<br>
						}<br>
						}<br>
						Мұндағы 1-операторда 3 символдық айнымалы сипатталған. Олар әр түрлі бейнелеуформаларын-дағы символдармен инициалданған. Сонан соң символдарды шығару және түрлендіруәрекеттері орындалады.<br>
						2-операторда пернелерден енгізілген символ талданады. Мұнда Ctrl пернесі мен латынәріптерін пайдаланып, басқару символдарын да енгізуге болады. Енгізу кезінде тіркесті бір ғанасимвол болуға тиіс char символына түрлендіретін Parse тәсілі пайдаланылған. Онда тіркесенгізілетіндіктен, символ соңынан Enter пернесі басылады. Цикл q символы енгізілгенше орындалабереді.<br>
						Олар әр түрлі бейнелеу формаларындағы символдармен инициалданған. Соңынан сим-волдарды шығару және түрлендіру әрекеттері орындалады.<br>
						1.2. Символдар жиымдары<br>
						Символдар жиымдары басқа типтегі массивтер тәрізді бұрын айтылған базалық Array класынегізінде құрылады.<br>
						Оның тәсілдерін мұнда қолдану бірсыпыра есептерді тиімді түрде шығару мүмкіндігін береді.<br>
						Енді бір мысал келтірейік.<br>
						Символдар жиымын пайдалану мысалы<br>
						using System;<br>
						namespace Listing 6_7<br>
						{ class Class1 { static void Main( )<br>
						{<br>
						char [ ] a = { 'm', 'a', 's', 's', 'i', 'v' }; // 1<br>
						char [ ] b = "а роза упала на лапу азора".ToCharArray(); // 2<br>
						PrintArray( "Исходный массив а:", a );<br>
						int pos = Array.IndexOf( a, 'm' );<br>
						a[pos] = 'M';<br>
						PrintArray( "Измененный массив а:", a );<br>
						PrintArray( "Исходный массив b:", b );<br>
						Array.Reverse( b );<br>
						PrintArray( "Измененный массив b:", b );<br>
						}<br>
						public static void PrintArray( string header, Array a )<br>
						{<br>
						Console.WriteLine( header );<br>
						foreach ( object x in a )<br>
						Console.Write( x );<br>
						Console.WriteLine( "\n" );<br>
						}<br>
						Программа жұмысы нәтижесі:<br>
						}<br>
						}<br>
						Символдық жиымды оның мәндерін бере отырып (1-оператор) немесе string класыныңToCharArray функциясын пайдалану жолымен тіркесті символ-дарға бөле отырып инициалдауғаболады.</p>
						<img src="img/7.jpg" alt="">
					</div>
					<!-- /.theme8 -->
					<div class="theme9">
						<h2 id="9">Класc тәсілдері мен операцияларының асыра жүктелуі</h2>	
						<ol>
							<li>Рекурсивтік тәсілдер, параметрлер саны айнымалы тәсілдер</li>
							<li>Индексаторлар</li>
							<li>Деструкторлар</li>
						</ol>
						<h3 id="9.1">Аргументтер саны айнымалы тәсілдер</h3>
						<pre><b>class Class1 {
						public static double Average( params int[] a ) {
						if ( a.Length == 0 )
						throw new Exception( «Аргументтері жеткіліксіз");
						double sum = 0;
						foreach ( int elem in a ) sum += elem;
						return sum / a.Length;
						}
						static void Main() { try {
						int[] a = { 10, 20, 30 };
						Console.WriteLine( Average( a ) ); // 1
						int[] b = { -11, -4, 12, 14, 32, -1, 28 };
						Console.WriteLine( Average( b ) ); // 2
						short z = 1, e = 13;
						byte v = 100;
						Console.WriteLine( Average( z, e, v ) ); // 3
						Console.WriteLine( Average() ); // 4
						}
						catch( Exception e ) {Console.WriteLine( e.Message ); return; }
						}}
						</b></pre>
						<h3>Рекурсивтік тәсілдер</h3>
						<p>Рекурсивтік деп өзін-өзі шақыратын (тура рекурсия) тәсілді атайды. Екі немесе одан да көптәсілдер бірін-бірі шақыратын болса, олар – жанама рекурсия деп аталады.</p>
						<p>Есептеулерді аяқтау үшін әрбір рекурсивтік тәсілдің кем дегенде бір қайтару операторыменаяқталатын рекурсивтік емес алгоритм тармағы болуы керек.</p>
						<pre><b>long fact( long n ) {
						if ( n == 0 || n == 1 ) return 1; // рекурсивтік емес тармақ
						return ( n * fact( n – 1 ) ); // рекурсивтік тармақ
						}
						… long m=fact(4);
						// немесе:
						long fact( long n ) { return ( n > 1 ) ? n * fact( n – 1 ) : 1; }
						</b></pre>
						<h3>Рекурсияның сипаттамалары</h3>
						<p>Атаулары бірдей, бірақ параметрлерінің типтері әртүрлі бірнеше тәсілдерді қатар қолданутәсілдердің асыра жүктелуі деп аталады.</p>
						<p>Компилятор берілген нақты параметрлердің типі бойынша қандай тәсілді шақыру керектігінанықтайды. Бұл асыра жүктелуге рұқсат беру (resolution) деп аталады.</p>
						<pre><b>// Екі бүтін санның үлкенінің мәнін қайтарады:
						int max( int a, int b )	
						// Үш бүтін санның үлкені мәнін қайтарады:
						int max( int a, int b, int c )
						// Бірінші параметрдің мәні үлкенін және екінші параметрдің ұзындығының үлкенінқайтарады:
						int max ( int a, string b )
						...
						Console.WriteLine( max( 1, 2 ) );
						Console.WriteLine( max( 1, 2, 3 ) );
						Console.WriteLine( max( 1, "2" ) );
						</b></pre>
						<p>Тәсілдердің асыра жүктелуі полиморфизм көрінісі болып табылады.</p>
						<h3>Класс операциялары</h3>
						<p>С# тіліндегі кластардың өз ішкі операцияларының басым бөлігі әрекеттерін қайта анықтауғаболады. Бұл стандартты типтегі айнымалылар сияқты өрнектердің құрамында объектэкземплярларын қолдануға мүмкіндік береді:</p>
						<pre><b>MyObject a, b, c; ...
						c = a + b; // MyObject класының қосу операциясы
						</b></pre>
						<p>Кластың өз операцияларын анықтау операциялардың асыра жүктелуі деп аталады.</p>
						<p>Класс операциялары арнайы түрдегі тәсілдер (функция-операциялар) арқылы былай сипатталады:</p>
						<p><b>public staticоперацияны_жариялаушы{ тұлға }</b></p>
						<p><b>Мысалы: public static MyObject operator --( MyObject m ) { … }</b></p>
						<p>C# тілінде класс операцияларының 3 түрі бар: унарлы, бинарлы және типті түрлендіруоперациялары.</p>
						<h3>Классоперацияларын сипаттаудың жалпы ережелері</h3>
						<p>Операция кластың ашық статикалық тәсілі ретінде сипатталуы тиіс (public static спецификаторлары);</p>
						<p>параметрлер операцияларға мәні бойынша берілуі тиіс (яғни, операция алдына ref немесе out түйінді сөздері жазылмауы тиіс);</p>
						<p>Кластың барлық операцияларының сигнатуралары әртүрлі болуы тиіс;
						операцияда қолданылатын типтер операциялардың өздерінен кем болмайтындай қатынасқұқықтарына ие болуы тиіс (яғни операцияларды қолданған кезде параметрлерге де қол жеткізугеболады).
						</p>
					</div>
					<!-- /.theme9 -->
					<div class="theme10">
						<h2 id="10">Кластарды мұралау<br></h2>
						<p><br>
						- Кластар иерархияларын (сатыларын) ұйымдастыру;<br>
						- Алдыңғы және соңғы байланыстыру;<br>
						- Виртуалды тәсілдер;<br>
						- Абстрактілі және туындысыз кластар;<br>
						- Кластар арасындағы өзара қатынас түрлері.<br>
						 <br>
						Мұралау мүмкіндіктері<br>
						- Мұралау ОБП-дың қуатты құралы болып табылады. Ол ұрпақ-кластардың ата-кластар қасиеттерін иемденетін және оларды толықтыру немесе өзгерту мүмкіндігіне ие болатын иерархияларды құруға мүмкіндік береді.<br>
						- Мұралау төмендегідей өзара байланысты мақсаттар үшін қолданылады:<br>
						- программадан қайталанатын код фрагменттерін жою;<br>
						- программаны өзгертуді жеңілдету;<br>
						- бұрын құрылған программалар негізінде жаңа программалар құруды жеңілдету.<br>
						- Сонымен қатар, программалардың бастапқы кодын пайдалануға мүмкіндік болмайтынжағдайда, оларға өзгеріс енгізуді қажет ететін объектілерді қолданудың жалғыз мүмкіндігі – осы мұралау болып табылады.<br>
						 <br>
						Синтаксисі (жазылуы):<br>
						[ атрибуттар ] [ спецификаторлар ] class класс_аты [ :ата_тектері ]<br>
						класс тұлғасы<br>
						<img src="img/8.jpg" alt="">
						 <br>
						class Monster<br>
						{ ... // private және public-тен басқа,<br>
						// protected қолданылады<br>
						}<br>
						class Daemon : Monster<br>
						{ ...<br>
						}<br>
						• C# тілінде кластың ұрпақтары саны бірнешеу болуы мүмкін<br>
						• Кластың тек бір ата-кластан және интерфейстердің кез келген санынан мұралау мүмкіндігі бар.<br>
						• Мұралау кезінде ұрпағы ата-тегінің барлық элементтерін қабылдайды.<br>
						• private элементтерін оның ұрпақтары тікелей пайдалана алмайды.<br>
						• protected элементтерін тек ұрпақтары пайдалана алады.<br>
						Кластың жалпы мысалы<br>
						class Monster {<br>
						public Monster() // конструктор<br>
						{<br>
						this.name = "Noname";<br>
						this.health = 100;<br>
						this.ammo = 100;<br>
						}<br>
						public Monster( string name ) : this() { this.name = name;<br>
						}<br>
						public Monster( int health, int ammo, string name )<br>
						{ this.name = name;<br>
						this.health = health; this.ammo = ammo;<br>
						} public int Health { // қасиет<br>
						get { return health;<br>
						}<br>
						set { if (value > 0) health = value;<br>
						else health = 0;<br>
						 }<br>
						 }<br>
						public int Ammo { // қасиет<br>
						get { return ammo;<br>
						}<br>
						set<br>
						{<br>
						if (value > 0) ammo = value;<br>
						else ammo = 0;<br>
						}<br>
						}<br>
						public string Name { // қасиет get<br>
						{ return name;<br>
						}<br>
						}<br>
						public void Passport() // тәсіл<br>
						{ Console.WriteLine(<br>
						"Monster {0} \t health = {1} \<br>
						ammo = {2}", name, health, ammo );<br>
						}<br>
						public override string ToString(){<br>
						string buf = string.Format(<br>
						"Monster {0} \t health = {1} \<br>
						ammo = {2}", name, health, ammo);<br>
						return buf;<br>
						}<br>
						string name; // private өрістер<br>
						int health, ammo;<br>
						Daemon, Monster класының мұрагері<br>
						class Daemon : Monster {<br>
						public Daemon() { brain = 1;<br>
						} public Daemon( string name, int brain ) :base( name ) this.brain = brain;<br>
						}<br>
						public Daemon( int health, int ammo, string name, int brain )<br>
						: base( health, ammo, name ) { this.brain = brain; }<br>
						 new public void Passport() {<br>
						Console.WriteLine( "Daemon {0} \t health ={1} ammo ={2} brain ={3}",<br>
						Name, Health, Ammo, brain );<br>
						}<br>
						public void Think()<br>
						{<br>
						Console.Write( Name + " is" );<br>
						for ( int i = 0; i < brain; ++i ) Console.Write( " thinking" );<br>
						Console.WriteLine( "..." ); } int brain; // жабық өріс<br>
						}<br>
						public void Passport() // тәсіл<br>
						{<br>
						Console.WriteLine( "Monster {0} \t health = {1} \ ammo = {2}", name, health, ammo );<br>
						}<br>
						 <br>
						Өрістер мен тәсілдерді мұралау<br>
						• Кластың өрістері, тәсілдері және қасиеттері мұраланады.<br>
						• Базалық класс элементін жаңа элементке алмастыру қажет болғанда new түйінді сөзін қолданғанжөн:<br>
						// Daemon класының тәсілдері (тегінің функцияларын толықтыру)<br>
						new public void Passport() {<br>
						base.Passport(); // ата-тегінің функцияларын қолдану<br>
						Console.WriteLine( brain ); // толықтыру<br>
						}<br>
						// Daemon класының тәсілі (толық алмастыру)<br>
						new public void Passport() {<br>
						Console.WriteLine( "Daemon {0} \t health ={1} ammo ={2} brain ={3}",<br>
						Name, Health, Ammo, brain );<br>
						}<br>
						// Monster класының тәсілі<br>
						public void Passport()<br>
						{<br>
						Console.WriteLine(<br>
						"Monster {0} \t health = {1} \<br>
						ammo = {2}",<br>
						name, health, ammo );<br>
						}<br>
						 <br>
						Виртуалды тәсілдерді қолдану<br>
						• Виртуалды тәсілдер туынды кластармен базалық класқа сілтеме жасау арқылы жұмыс істегендеқолданылады.<br>
						• Сонымен қатар, объектілерді тәсілдерге параметр ретінде беру кезінде виртуалды тәсілдерқолданылады. Тәсілдің параметрлерінде базалық типті объект сипатталады, ал шақыру кезінде оғантуынды класс объектісі беріледі. Бұл жағдайда тәсілдің ішіндегі объект үшін шақырылатынвиртуалды тәсілдер параметрдің емес, аргументтің типіне сәйкес болады.<br>
						• Кластарды сипаттау кезінде виртуалды тәсілдер ретінде туынды кластарда басқа жолменорындалатын тәсілдерді анықтау ұсынылады. Егер иерархияның барлық кластарында тәсілбірыңғай жүзеге асатын болса, оны жай тәсіл ретінде анықтаған жөн.<br>
						 <br>
						Абстрактілі кластар<br>
						• Абстрактілі класс тек ұрпақтарды тудыру үшін қолданылады. Әдетте онда ұрпақтардыңәрқайсысы өзінің қолданатын жолымен жүзеге асыратын тәсілдер жиыны беріледі. Абстрактілікластар туынды кластарда нақтылануы жоспарланатын жалпы ұғымдарды бейнелеуге арналған.<br>
						• Абстрактілі класс иерархия үшін толықтай интерфейсті анықтайды және бұл кезде класстәсілдеріне ешбір нақты әрекеттер сәйкес келмеуі мүмкін. Бұл жағдайда тәсілдердің тұлғасы босболады және олар abstract спецификациясымен жарияланады.<br>
						• Егер класта кем дегенде бір абстрактілі тәсіл бар болса, класс түгелдей абстрактілі класс ретінде(abstract спецификаторымен) сипатталуы тиіс.<br>
						• Абстрактілі кластың құрамында толықтай анықталған тәсілдер де болуы мүмкін, бұл оныңинтерфейстен айырмашылығы.<br>
						Полиморфты тәсілдер<br>
						• Абстрактілі кластар келесі жағдайларда қолданылады:<br>
						• бір иерархияның объектілерін сақтауға арналған мәліметтер құрылымдарымен жұмыс істеукезінде<br>
						• тәсілдердің параметрлері ретінде.<br>
						• Егер абстрактілі кластан туындаған класс барлық абстрактілі тәсілдерді қайта анықтайтынболмаса, ол да абстрактілі класс ретінде сипатталуы тиіс.<br>
						• Параметрі абстрактілі класс болатындай тәсіл құруға мүмкіндігі бар. Программаның орындалуыбарысында бұл параметрдің орнына кез келген туынды кластың объектісі берілуі мүмкін. Бұл біриерархия шеңберіндегі кез келген типті объектімен жұмыс істейтін полиморфты тәсілдерді құруғамүмкіндік береді.<br>
						Жүзеге асырылған тәсілге интерфейс типті объект арқылы қатынас құру<br>
						 Бұл жолдың ыңғайлылығы IAction типті объектілерге осы интерфейсті қолдайтын әртүрлі классобъектілеріне сілтемені меншіктеу кезінде байқалады.<br>
						 Мысалы, интерфейс типті параметрі бар тәсіл бар болсын. Бұл параметрдің орнына интерфейстіжүзеге асыратын кез келген объектіні беруге болады:<br>
						static void Act( IAction A )<br>
						{<br>
						A.Draw();<br>
						}<br>
						static void Main()<br>
						{<br>
						Monster Vasia = new Monster( 50, 50, "Вася" );<br>
						Act( Vasia );<br>
						...<br>
						}<br>
						Интерфейстер және мұралау<br>
						 Интерфейстің ата-тегі болмауы мүмкін немесе олардың саны бірнешеу болуы да мүмкін, соңғыжағдайда ол ең жоғарғы деңгейден бастап, өзінің барлық базалық интерфейстерінің барлықэлементтерін мұралайды.<br>
						 Базалық интерфейстерге олардың ұрпақтарынан кем болмайтындай деңгейде қол жеткізілетінболуы тиіс.<br>
						 Әдеттегі кластар иерархиясы сияқты, базалық интер-фейстер жалпылама әрекеттер сипатынанықтайды, ал олардың ұрпақтары оны нақтылайды және толықтырады.<br>
						 Сонымен қатар, ұрпақтар интерфейсінде сигнатурасы бірдей, мұраланған элементтерді қайтаанықтаушы элементтерді көрсетуге болады. Мұндайда элементтің алдына кластардағы сияқты new түйінді сөзі жазылады. Осы сөздің көмегімен базалық интерфейстің соларға сәйкес элементіжасырылады.<br>
						 <br>
						Мысал<br>
						interface IBase { void F( int i ); }<br>
						interface Ileft : IBase {<br>
						new void F( int i ); /* F тәсілін қайта анықтау */ }<br>
						interface Iright : IBase { void G(); }<br>
						interface Iderived : ILeft, IRight {}<br>
						class A {<br>
						void Test( IDerived d ) {<br>
						d.F( 1 ); // ILeft.F шақырылады<br>
						((IBase)d).F( 1 ); // IBase.F шақырылады<br>
						((ILeft)d).F( 1 ); // ILeft.F шақырылады<br>
						((IRight)d).F( 1 ); // IBase.F шақырылады<br>
						}<br>
						}<br>
						IDerived — IRight — IBase тізбегінде қайта анықталмағанына қарамастан, IBase интерфейсінің Fтәсілі ILeft интерфейсімен жасырылған.<br>
						 <br>
						Интерфейстерді жүзеге асырудың ерекшеліктері<br>
						 Интерфейсті жүзеге асыратын класс оның барлық элементтерін, оның ішінде, мұраланғандарында анықтауы керек. Егер осындай жағдайда интерфейстің аты нақты түрде көрсетілетін болса, олосыған сәйкес элемент сипатталған интерфейске сілтеме жасауы тиіс.<br>
						 Өзіндік немесе мұраланған элементтерге нақты сілтеме жасайтын интерфейс класс ата-тектерітізімінде көрсетілуі тиіс.<br>
						 Класс өзінің ата тегінің барлық тәсілдерін, оның ішінде, интерфейстерді жүзеге асырғандарын дамұралайды. Ол осы тәсілдерді new спецификаторының көмегімен қайта анықтай алады, алайдаолармен тек класс объектісі арқылы ғана қатынас құруға болады.<br>
						 <br>
						Стандартты .NET интерфейстері<br>
						 .NET кластар кітаханасында объектілердің қажетті әрекет-терін тағайындайтын көптегенстандартты интерфейстер анықталған. Мысалы, IComparable интерфейсі объекті-лерді «үлкен-кіші» деген сияқты салыстыру тәсілін тағайындайды, бұл оларды реттеуге мүмкіндік береді.<br>
						 IEnumerable және IEnumerator интерфейстерін жүзеге асыру foreach көмегімен объект құрамынкөруге, ал ICloneable интерфейсін жүзеге асыру объектілерді клондауға мүмкіндік береді.<br>
						 Стандартты интерфейстерді кітапхананың көптеген стандартты кластары сүйемелдейді. Мысалы, foreach көмегімен жиыммен жұмыс істеу мүмкіндігінің болу себебі – Array типі IEnumerable жәнеIEnumerator интерфейс-терін жүзеге асырады.<br>
						 Стандартты интерфейстерді сүйемелдейтін өз кластары-мызды да құруға болады, бұл осыкластар объектілерін стандартты тәсілдер көмегімен пайдалануға мүмкіндік береді.<br>
						 <br>
						Объектілерді салыстыру<br>
						 IComparable интерфейсі System атаулар кеңістігінде анықталған. Оның құрамында тек бір ғанаCompareTo тәсілі бар, ол екі объектіні – ағымдағы және оған параметр ретінде берілген объектілердісалыстыру нәтижесін қайтарады.<br>
						interface<br>
						IComparable {<br>
						int CompareTo( object obj )<br>
						}<br>
						 Тәсіл төмендегідей нәтижелерді қайтаруы тиіс:<br>
						 0, егер ағымдағы объект пен параметр тең болса;<br>
						 теріс сан, егер ағымдағы объект параметрден кіші болса;<br>
						 оң сан, егер ағымдағы объект параметрден үлкен болса.<br>
						 <br>
						Программалау үшін берілетін ұсыныстар<br>
						 Мұралаудың негізгі артықшылығы – базалық класс деңгейінде туынды класс объектілерімен де жұмыс істеуге мүмкіндік беретін универсалды код жазуға болады, бұл виртуалды тәсілдеркөмегімен жүзеге асырылады.<br>
						 Виртуалды тәсілдер ретінде иерархияның барлық кластарында бір функцияны (мүмкін әртүрлітәсілдермен) атқаратын тәсілдер сипатталуы тиіс.<br>
						 Туынды кластарда нақтылануы жоспарланатын жалпы ұғымдарды бейнелеу үшін абстрактілікластар қолданылады. Әдетте абстрактілі класта ұрпақтардың әрқайсысы өзінің қолданатынжолымен жүзеге асыратын тәсілдер жиыны, яғни интерфейс беріледі.<br>
						 Жай тәсілдерді (виртуалды емес) туынды класта қайта анықтау ұсынылмайды.</p>
					</div>
					<!-- /.theme10 -->
					<div class="theme11">
						<h2 id="11">Кластардың негізгі элементтері: өрістерді, тәсілдерді, конструкторларды, қасиеттердіпайдалану жолдары</h2>
						<ol>
							<li>Кластар туралы жалпы мәліметтер</li>
							<li>Класс спецификаторлары</li>
							<li>Класс объектілерін жасау</li>
							<li>Объектілерді меншіктеу және салыстыру</li>
							<li>Мәліметтер: өрістер мен константалар</li>
							<li>Класс өрісінің спецификаторлары мен константалары</li>
							<li>Тәсілдер</li>
							<li>Тәсілдер параметрлері</li>
							<li>Тәсілді шақыру</li>
							<li>Параметрлерді беру тәсілдері және олардың типтері</li>
							<li>Параметрлерді қолдану ережелері</li>
							<li>this түйінді сөзі</li>
							<li>Конструкторлар</li>
							<li>Қасиеттер</li>
						</ol>
						<p>Класс сипаттамасы class түйінді сөзі мен класс атынан тұрады да, жүйелі жақша ішінде класс тұлғасы – оның элементтері тізімі орналасады. Бұларға қоса, кластың базалық элементтерін (тегі-предки) және әртүрлі сипаттары анықталатын, міндетті емес бірсыпыра атрибуттары мен спецификаторларын беруге болады.</p>
						<p>Тәсіл — класпен немесе экземплярмен атқарылатын есептеу-лерді орындайтынфункционалдық элемент. Тәсілдер кластың тәртібін анықтайды да, оның интерфейсін құрайды.</p>
						<p>Тәсіл — аты арқылы пайдалануға болатын, аяқталған код фрагменті. Ол бір рет жазылады да, қанша рет қажет болса, сонша рет шақырылып орындала береді.</p>
						<p>Бір тәсіл оған аргумент ретінде берілген әртүрлі мәліметтерді өңдей алады.</p>
						<p>Төмендегі мысалға қараңыз:<br>
						Тәсілге параметрлерді беру мысалы</p>
						<pre><b>using System;
						namespace Lisning5_3 {
						class Class1 { static int Max(int a, int b) // макс. мәнді таңдау
						{ if ( a > b ) return a;
						else return b;
						}
						static void Main()
						{ int a = 2, b = 4;
						int x = Max( a, b ); // Max тәсілін шақыру
						Console.WriteLine( x ); // нәтижесі: 4
						short t1 = 3, t2 = 4;
						int y = Max( t1, t2 ); // үйлесімді тип пар-рлері
						Console.WriteLine( y ); // нәтижесі : 4
						int z = Max( a + t1, t1 / 2 * b ); // өрнек
						Console.WriteLine( z ); // нәтижесі : 5
						}
						}
						}
						</b></pre>
						<h3>Параметрлерді беру тәсілдері және олардың типтері</h3>
						<p>Параметрлерді беру тәсілдері: мән бойынша және сілтеме бойынша. Параметрлерді мәнбойынша беру кезінде тәсіл аргументтер мәнінің көшірмелерін алады да, тәсіл операторлары осы көшірмелермен жұмыс істейді.</p>
						<p>Параметрлерді сілтеме (адрес) бойынша беру кезінде тәсіл аргументтер адресінің көшірмесіналады да, сол (бұрынғы) адрестердегі аргументтерді пайдаланады.</p>
						<p>С# тілінде параметрлердің төрт типі бар:</p>
						<ul>
							<li>мән-параметрлер;</li>
							<li>сілтеме-параметрлер (ref);</li>
							<li>нәтижелік (шығыс - выходные) параметрлер (out);</li>
							<li>жиым-параметрлер (params).</li>
						</ul>
						<p>Түйінді сөздер параметрлер типтерін сипаттаудың алдында тұрады. Егер ол болмаса, параметр мән-параметр болып есептеледі. Мысалы:</p>
						<pre><b>public int Calculate( int a, ref int b, out int c, params int[] d ) …
						Мысал: мән-параметрлер мен ref сілтемелері
						using System;
						namespace Listing5_4
						{ class Class1
						{ static void P( int a, ref int b )
						{
						a = 44;
						b = 33;
						Console.WriteLine( "тәсіл ішінде {0} {1}", a, b );
						} static void Main()
						{
						int a = 2, b = 4;
						Console.WriteLine( "шақыруға дейін {0} {1}", a, b );
						P( a, ref b );
						Console.WriteLine("шақырудан кейін {0} {1}", a, b );
						}
						}
						}
						Мысал: out шығыс параметрлері
						using System;
						namespace Listing5_5
						{ class Class1
						{ static void P( int x, out int y )
						{
						x = 44; y = 33;
						Console.WriteLine( " тәсіл ішінде {0} {1}", x, y );
						}
						static void Main()
						{
						int a = 2, b; // b-ны инициалдау қажет емес
						P( a, out b );
						Console.WriteLine( "шақырудан кейін {0} {1}", a, b );
						}
						}
						}
						</b></pre>
						<p><b>Мән</b>-параметрлер үшін мән бойынша параметр беру қолданылады. Бұл мүмкіндік тәсілдіңбастапқы мәліметтері үшін қолданылады.</p>
						<p>Тәсілді шақыру кезінде мән бойынша берілетін параметр орнында өрнек болуы мүмкін (жәнеде оның жеке жағдайы ретінде — айнымалы немесе константа). Мұнда өрнек типі параметр типінекелтірілуі керек.</p>
						<p>Сілтеме-параметрлер және нәтижелік (шығыс) параметрлер адрес бойынша беріледі. Мұндай мүмкіндік тәсілдің қосалқы нәтижелерін (побочные результаты) беру кезінде қолданылады.</p>
						<p>Тәсілді шақыру кезінде ref сілтемесі бойынша берілетін параметр орнында тек сол типтегіинициалданған айнымалы аты ғана болуы мүмкін. </p>
						<p>Параметр аты алдында ref түйінді сөзікөрсетіледі.<br>
						Тәсілді шақыру кезінде out нәтижелік (шығыс) параметр орнында тек сол типтегі айнымалыаты ғана болуы мүмкін. Оны инициалдау қажет емес. Параметр аты алдында out түйінді сөзі көрсетіледі. </p>
						<h3>This түйінді сөзі</h3>
						<p>Тәсілдің ол өңдеуге тиіс объект өрісімен жұмыс істеуін қамтамасыз ету үшін, сол тәсілгеавтоматты түрде this жасырын параметрі беріледі, ол функцияны шақырған объектіге сілтеме жасаптұрады.</p>
						<pre><b>this сөзін нақты түрде пайдалану
						this параметрі тікелей түрде мынадай жағдайларда қолданылады:
						// тәсілден оны шақырған объектіге сілтеме қайтару үшін:
						class Demo
						{ double y;
						public Demo T() { return this;
						} // аты тәсіл параметрі атымен бірдей өрісті идентификациялауүшін:
						public void Sety( double y ) { this.y = y; }
						}
						</b></pre>
						<h3> Конструкторлар</h3>
						<p>Конструктор объектіні инициалдау үшін қажет. Ол класс объектісін жасау кезінде newоперациясы арқылы шақырылады. Конструктор аты класс атымен бірдей болады.</p>
						<p>Конструкторлар қасиеттері:<br>
						Конструктор ешқандай мән (тіпті void типін де) қайтармайды. Кластың, инициалдаудың әртүрлері үшін әртүрлі параметрлері бар, бірнеше конструкторлары болуы мүмкін.
						</p>
						<p>Егер программалаушы бірде-бір конструкторды көрсетпесе немесе кейбір өрістеринициалданбаса, мәндік типтегі өрістерге — нөл, ал сілтемелік типтегі өрістерге — null мәніменшіктеледі.</p>
						<p>Параметрсіз шақырылатын конструктор (үнсіз) келісім бойынша алынған конструктор деп аталады.
						Конструкторы бар класс мысалы
						</p>
						<pre><b>using System;
						namespace Listing5_6 {
						class Demo { public Demo( int a, double y ) // конструктор
						{ this.a = a; this.y = y; }
						int a; double y;
						}
						class Class1
						{
						static void Main()
						{
						Demo a = new Demo( 300, 0.002 ); // конструкторды шақыру
						Console.WriteLine( a.Gety() ); // нәтиже: 0,002
						Demo b = new Demo( 1, 5.71 ); // конструкторды шақыру
						Console.WriteLine( b.Gety() ); // нәтиже : 5,71
						} } }
						Екі конструкторы бар класс мысалы
						class Demo
						{
						public Demo( int a ) // 1 конструктор
						{
						this.a = a;
						this.y = 0.002;
						}
						public Demo( double y ) // 2 конструктор
						{
						this.a = 1;
						this.y = y;
						}
						...
						}
						...
						Demo x = new Demo( 300 ); // 1 конструкторды шақыру
						Demo y = new Demo( 5.71 ); // 2 конструкторды шақыру
						Жалпы класс мысалы
						class Monster {
						public Monster() // конструктор
						{
						this.name = "Noname";
						this.health = 100;
						this.ammo = 100;
						} public Monster( string name ) : this() { this.name = name;
						} public Monster( int health, int ammo, string name )
						{ this.name = name; this.health = health; this.ammo = ammo;
						}
						public int GetName() // тәсіл { return name;
						} public int GetAmmo() // тәсіл { return ammo;
						}
						</b></pre>
						<h3>Қасиеттер</h3>
						<p>Қасиеттер класс өрістерімен қатынас құру үшін пайдаланылады. Көбінесе, қасиет жабықөрістермен қатынас құру тәсілдерін анықтайды.<br>
						Қасиет синтаксисі:
						</p>
						<pre><b>[ спецификаторлар ] типі қасиет_аты
						{
						[ get қатынасу_коды ]
						[ set қатынасу_коды ]
						}
						</b></pre>
						<p>Қасиеттерді пайдалану кезінде, автоматты түрде онда көрсетілген оқу (get) және орнату (set) блоктары шақырылады.</p>
						<p>Мұнда не get, не set бөлігі болмауы мүмкін, бірақ екеуінің де бірден жоқ болуы мүмкін емес. Егер set бөлігі болмаса, қасиет тек оқылады (read-only), ал егер get бөлігі болмаса – тек жазылады(write-only)</p>
					</div>
					<!-- /.theme11 -->
				</div> <!-- container -->
			</div>
		</div>
	</div>
</body>
</html>	